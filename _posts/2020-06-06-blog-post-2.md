---
layout: post
title: "[한글 문서화] Blog Post(2)"
author: "OSS-5"
---

>word_cloud [blog post][Blog] 의 "The integral image is basically a 2d cumulative sum and can be computed as ~" 부분부터 한국어로 번역한 문서입니다.
<hr>

적분 이미지(integral image)는 기본적으로 2d 누적 합이며, 다음과 같이 계산할 수 있습니다.
```python
integral_image = np.cumsum(np.cumsum(image, axis=0), axis=1)
```
이 작업을 수행하면 어떤 사이즈의 직사각형이든 빠르게 찾을 수 있습니다. 만약 사이즈 (w, h)의 창(windows)의 경우, 다음과 같이 가능한 모든 창의 합을 계산할 수 있습니다.
```python
area = (integral_image[w:, h:] + integral_image[:w, :h] - integral_image[w:, :h] - integral_image[:w, h:])
```
이는 모든 위치를 동시에 쿼리하기 위한 적분 이미지 쿼리 ( [wikipedia 참조][Wiki] )와 제가 좋아하는 numpy 트릭의 조합입니다.

기본적으로 이것은 위의 convolution과 같으며, 가능한 모든 창 사이즈를 쿼리할 수 있도록 구조(structure)을 먼저 계산합니다.

단어를 그린 후에는 다시 적분이미지를 계산해야 합니다.

아쉽게도 적분 이미지를 사용한 멋진 인덱싱은 살짝 느렸습니다.

반면에 Pycon DE의 [Stefan Behnel][Stefan] 에게 배운 Cython의 [typed memory views][Typed] 를 시도해 볼 수 있는 좋은 기회이기도 했습니다 :)
```python
def query_integral_image(unsigned int[:,:] integral_image, int size_x, int size_y):
    cdef int x = integral_image.shape[0]
    cdef int y = integral_image.shape[1]
    cdef int area, i, j
    x_pos, y_pos = []
    for i in xrange(x - size_x):
        for j in xrange(y - size_y):
            area = integral_image[i, j] + integral_image[i + size_x, j + size_y]
            area -= integral_image[i + size_x, j] + integral_image[i, j + size_y]
            if not area:
                x_pos.append(i)
                y_pos.append(j)
```
좋습니다! 쓰기 쉽고 C-Speed에 직접적입니다.
[Blog]: https://peekaboo-vision.blogspot.com/2012/11/a-wordcloud-in-python.html
[Wiki]: https://en.wikipedia.org/wiki/Summed-area_table
[Typed]: http://docs.cython.org/en/latest/src/userguide/memoryviews.html
[Stefan]: http://consulting.behnel.de
